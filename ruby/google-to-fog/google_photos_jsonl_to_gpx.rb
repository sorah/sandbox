#!/usr/bin/env ruby

require 'json'
require 'time'
require_relative 'gpx_utils'

class GooglePhotosJsonlToGPX
  include GPXUtils
  
  def initialize(output_io = $stdout)
    @output_io = output_io
    @tracks = []
  end

  def convert(input_files)
    parse_jsonl_files(input_files)
    create_tracks_from_photos
    filter_tracks
    generate_gpx
  end

  private

  def filter_tracks
    @tracks = GPXUtils.filter_tracks(@tracks)
  end

  def parse_jsonl_files(files)
    all_geotags = []
    
    files.each do |file_path|
      File.open(file_path, 'r') do |file|
        file.each_line do |line|
          next if line.strip.empty?
          
          begin
            data = JSON.parse(line)
            
            next if data['type'] == 'error' || data['type'] == 'warning'
            
            if data['lat'] && data['lon'] && data['time']
              all_geotags << {
                lat: data['lat'].to_f,
                lon: data['lon'].to_f,
                time: Time.parse(data['time']),
                filename: data['filename'],
                tarball: data['tarball'],
                altitude: data['altitude']
              }
            end
          rescue JSON::ParserError => e
            warn "Failed to parse line in #{file_path}: #{e.message}"
          rescue => e
            warn "Error processing line in #{file_path}: #{e.message}"
          end
        end
      end
    end
    
    @all_geotags = all_geotags.sort_by { |g| g[:time] }
  end

  def create_tracks_from_photos
    return if @all_geotags.empty?
    
    time_gap_threshold = 30 * 60 # 30 minutes
    distance_gap_threshold = 1000 # 1km (same as timeline GPX)
    current_track_points = []
    track_start_time = @all_geotags.first[:time]
    
    @all_geotags.each_with_index do |geotag, index|
      track_point = GPXUtils::TrackPoint.new(
        lat: geotag[:lat],
        lon: geotag[:lon],
        time: geotag[:time],
        name: File.basename(geotag[:filename])
      )
      
      should_start_new_track = false
      
      if index > 0
        prev_geotag = @all_geotags[index - 1]
        time_diff = geotag[:time] - prev_geotag[:time]
        
        distance = GPXUtils.haversine_distance(
          prev_geotag[:lat], prev_geotag[:lon],
          geotag[:lat], geotag[:lon]
        )
        
        # Start new track if time gap > 30 min OR distance gap > 1km
        if time_diff > time_gap_threshold || distance > distance_gap_threshold
          should_start_new_track = true
        end
      end
      
      if should_start_new_track
        if current_track_points.length >= 2
          @tracks << GPXUtils::Track.new(
            name: "Photos - #{track_start_time.strftime('%Y-%m-%d %H:%M')}",
            points: current_track_points
          )
        end
        
        current_track_points = []
        track_start_time = geotag[:time]
      end
      
      current_track_points << track_point
    end
    
    if current_track_points.length >= 2
      @tracks << GPXUtils::Track.new(
        name: "Photos - #{track_start_time.strftime('%Y-%m-%d %H:%M')}",
        points: current_track_points
      )
    end
  end

  def generate_gpx
    GPXUtils.generate_gpx(
      tracks: @tracks,
      waypoints: [],
      creator: 'Google Photos JSONL to GPX Converter',
      track_name: 'Google Photos Track',
      output_io: @output_io
    )
  end
end

if __FILE__ == $0
  if ARGV.length == 0
    $stderr.puts "Usage: #{$0} <input1.jsonl> [input2.jsonl ...] > output.gpx"
    $stderr.puts "       #{$0} photos*.jsonl > photos_tracks.gpx"
    $stderr.puts ""
    $stderr.puts "Converts JSONL files containing photo geotag data to GPX format."
    $stderr.puts "Input files should be generated by google_photos_exif_to_jsonl.rb"
    exit 1
  end

  missing_files = ARGV.reject { |file| File.exist?(file) }
  unless missing_files.empty?
    $stderr.puts "Error: Files not found: #{missing_files.join(', ')}"
    exit 1
  end

  converter = GooglePhotosJsonlToGPX.new($stdout)
  converter.convert(ARGV)
  
  $stderr.puts "Conversion complete!"
end